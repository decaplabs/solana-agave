name: Build setup
description: Setup before build

inputs:
  image-name:
    description: The name of the image built for this module, only the name, not including the registry address.
    required: true
  target-env:
    description: |
      The deployment environment, such as dev qa uat load stg prod. Can be either a single name or a comma-separated list of names.
      Note: stg and prod must not be mixed with other environments. stg and prod must not be deployed at the same time.
    required: true

  # Arguments for Azure
  azure-acr-secret:
    description: |
      The value comes from secrets.AZURE_ACR_SECRET. If this input is not provided, the action will look for environment
      variable AZURE_ACR_SECRET
    required: false

  push:
    description: Whether or not we'll be deploying the image
    type: boolean
    required: false
    default: true

  vars:
    description: from the caller workflow, just pass this function call toJson(vars)
    required: true

  push-registry:
    description: the registry to push the image to
    required: true



  prod_stg_acct:
    description: account ID of prod/staging account
    required: false
    type: string
    default: 653832775139
  
  nonprod_acct:
    description: account ID of nonprod account
    required: false
    type: string
    default: 653832775139

runs:
  using: composite
  steps:
    - name: process action variables
      shell: bash
      run: |
        # step: process action variables

        # controls behaviors of docker build
        echo "DOCKER_BUILD_SUMMARY=false" >> $GITHUB_ENV
        echo "DOCKER_BUILD_RECORD_UPLOAD=false" >> $GITHUB_ENV
        echo "DOCKER_BUILD_CHECKS_ANNOTATIONS=false" >> $GITHUB_ENV


        if ! ${{ inputs.push }}; then
            # All the checks below are for deployments - azure, environments, ...
            echo "::info ::Not pushing; skipping target, env, and key checks."
            exit 0
        fi

        # Check mandatory inputs
        if [ "${{ inputs.image-name }}" = "" ]; then echo "::error ::input argument image-name must not be empty"; exit 1; fi
        if [ "${{ inputs.target-env }}" = "" ]; then echo "::error ::input argument target-env must not be empty"; exit 1; fi
        if [ "${{ inputs.push-registry }}" = "" ]; then echo "::error ::input argument push-registry must not be empty"; exit 1; fi

        # Check mandatory vars
        if [ "${{ fromJson(inputs.vars).AWS_GA_ROLE_ARN_PROD }}" = "" ]; then echo "::error ::AWS_GA_ROLE_ARN_PROD is not defined in any variable scope"; exit 1; fi
        
        # validate target-env
        # make sure prod,stg do not mix with other values
        IFS=',' read -ra env_list <<< "${{ inputs.target-env }}"
        has_prod_or_stg=false
        has_nonprod=false
        for deployment_env in "${env_list[@]}"; do
          # trim all whitespaces
          deployment_env=$(echo "$deployment_env" | tr -d '[:space:]')
          if [ "$deployment_env" == "prod" ] || [ "$deployment_env" == "stg" ]; then
            has_prod_or_stg=true
          elif [ "$deployment_env" != "" ]; then
            has_nonprod=true
          fi
        done
        if [ "$has_prod_or_stg" = true ] && [ "$has_nonprod" = true ]; then
          echo "::error ::target-env must not mix prod/stg with other nonprod environments: ${{ inputs.target-env }}"
          exit 1
        fi
        
        if [ "${{ fromJson(inputs.vars).PULL_IMAGE_REPO }}" = "" ]; then
          if [ "$has_prod_or_stg" = true ]; then
            echo "PULL_IMAGE_REPO=${{ inputs.prod_stg_acct }}.dkr.ecr.us-east-2.amazonaws.com/" >> $GITHUB_ENV
          else
            echo "PULL_IMAGE_REPO=${{ inputs.nonprod_acct }}.dkr.ecr.us-east-2.amazonaws.com/" >> $GITHUB_ENV
          fi
        else
          echo "PULL_IMAGE_REPO=${{ fromJson(inputs.vars).PULL_IMAGE_REPO }}" >> $GITHUB_ENV
        fi
        
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      if: ${{ runner.environment == 'self-hosted' }}
      with:
        cleanup: true

    - name: Set up Docker Buildx
      if: ${{ runner.environment != 'self-hosted' }}
      uses: docker/setup-buildx-action@v3

    - name: Set short hash env var
      shell: bash
      run: |
        echo "GITHUB_SHA_SHORT=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

    - name: Push Runs
      if: ${{ inputs.push == 'true' }}  # github interprets this as a string, and "false" is true.
      shell: bash
      run: |
        echo "inputs.push evaluated to ${{ inputs.push }}; ran the Push Runs step."

    - name: make image tags
      if: ${{ inputs.push == 'true' }}  # github interprets this as a string, and "false" is true.
      id: make-tags
      shell: bash
      run: |
        set -x
        # step: make image tags
        primary_image_tag="${{ env.GITHUB_SHA_SHORT }}"
        push_image_uris="${{ inputs.push-registry }}"
        push_image_uris="${push_image_uris%/}/${{ inputs.image-name }}:${{ env.GITHUB_SHA_SHORT }}"
        
        # the Primary tag must always be the first tag in the list
        desired_image_tags="$primary_image_tag"

        IFS=',' read -ra ENV_LIST <<< "${{ inputs.target-env }}"
        for deployment_env in "${ENV_LIST[@]}"; do
          # trim all whitespaces
          deployment_env=$(echo "$deployment_env" | tr -d '[:space:]')
          if [ "$deployment_env" != "" ]; then
            # desired_image_tags="${desired_image_tags},${deployment_env}-latest"
            desired_image_tags="${desired_image_tags},${deployment_env}--${{ env.GITHUB_SHA_SHORT }}"
            # push_image_uris="${push_image_uris},${{ inputs.push-registry }}/${{ inputs.image-name }}:${deployment_env}-latest"
            push_image_uris1='${{ inputs.push-registry }}'
            push_image_uris="${push_image_uris},${push_image_uris1%/}/${{ inputs.image-name }}:${deployment_env}--${{ env.GITHUB_SHA_SHORT }}"
          fi
        done

        echo "PRIMARY_IMAGE_TAG=${primary_image_tag}" >> $GITHUB_ENV
        echo "desired-image-tags=${desired_image_tags}" >> "$GITHUB_OUTPUT"
        echo "PUSH_IMAGE_URIS=${push_image_uris}" >> $GITHUB_ENV

    - name: Get all existing tags of the repo
      if: ${{ inputs.push == 'true' }}  # github interprets this as a string, and "false" is true.
      id: get-repo-tags
      shell: bash
      run: |
        set -x
        # step: Get all existing tags of the repo
        # one tag on a line
        all_tags=""
        max_attempts=3
        for ((i=1; i<=max_attempts; i++)); do
          set +e
          # ACR CLI may fail intermittently, especially when multiple modules are built at the same time.
          # XXX This is the wrong kind of "tag"
          all_tags=$(aws ecr list-images --repository-name '${{ inputs.image-name }}' |
                        jq -rc '.imageIds[].imageTag | select (.)')
          status_code=$?
          set -e
          if [ $status_code -eq 0 ]; then
            break
          fi

          if [ $i -eq $max_attempts ]; then
            echo "::warning ::Unable to get tags of repo '${{ inputs.image-name }}' after $max_attempts attempts."
          else
            sleep $((10 + i * 5))
            echo "${i} - retry getting all tags of repo '${{ inputs.image-name }}'"
          fi
        done
        escaped_tags=$(echo "$all_tags" | tr '\n' ',')
        echo "all-tags=$escaped_tags" >> "$GITHUB_OUTPUT"

    - name: Determine if the image has already been built
      id: determine-existing-image
      if: ${{ steps.get-repo-tags.outputs.all-tags != '' && inputs.push }}
      shell: bash
      run: |
        set -x
        # step: Determine if the image has already been built
        IFS=',' read -ra desired_tags <<< "${{ steps.make-tags.outputs.desired-image-tags }}"
        all_tags="${{ steps.get-repo-tags.outputs.all-tags }}"
        all_tags=$(echo "$all_tags" | tr ',' '\n')
        existing_tag=""
        for tag in "${desired_tags[@]}"; do
          if [[ "$tag" == *latest ]]; then
            continue
          fi
          if echo "$all_tags" | grep -Fxq "$tag"; then
            existing_tag="$tag"
            break
          fi
        done

        # it's very dangerous to use latest as existing tag. Just to make sure it won't happen, by any mistake
        if [[ "$existing_tag" == *latest ]]; then
          echo "::error ::'latest' must be used as an existing tag. Found: $existing_tag"
          exit 1
        fi
        
        echo "existing-tag=$existing_tag" >> "$GITHUB_OUTPUT"

    - name: Determine missing tags
      id: determine-missing-tags
      if: ${{ steps.determine-existing-image.outputs.existing-tag != '' && inputs.push }}
      shell: bash
      run: |
        set -x
        # step: Determine missing tags
        all_tags="${{ steps.get-repo-tags.outputs.all-tags }}"
        all_tags=$(echo "$all_tags" | tr ',' '\n')
        existing_tag="${{ steps.determine-existing-image.outputs.existing-tag }}"
        IFS=',' read -ra desired_tags <<< "${{ steps.make-tags.outputs.desired-image-tags }}"
        
        missing_image_tags=()
        for tag in "${desired_tags[@]}"; do
          if [[ "$tag" == "$existing_tag" ]]; then
            continue
          fi
          if ! echo "$all_tags" | grep -Fxq "$tag"; then
            missing_image_tags+=("$tag")
          fi
        done
        echo "missing_image_tags: ${missing_image_tags[@]}"
        
        missing_tags_csv=$(IFS=, ; echo "${missing_image_tags[*]}")
        echo "missing-tags=${missing_tags_csv}" >> "$GITHUB_OUTPUT"
        echo "ALREADY_BUILT=yes" >> $GITHUB_ENV
        echo "::notice ::Image ${{ inputs.image-name }}:$existing_tag exists in ACR. Skip re-building it"

    - name: Pull existing image
      id: pull-existing-image
      if: ${{ steps.determine-missing-tags.outputs.missing-tags != '' && inputs.push }}
      shell: bash
      run: |
        set -x
        # step: Pull existing image
        existing_tag="${{ steps.determine-existing-image.outputs.existing-tag }}"

        max_attempts=3
        
        for ((i=1; i<=max_attempts; i++)); do
          set +e
          push_registry1='${{ inputs.push-registry }}'
          docker pull "${push_registry1%/}/${{ inputs.image-name }}:$existing_tag"
          status_code=$?
          set -e
          if [ $status_code -eq 0 ]; then
            echo "image-pulled=yes" >> "$GITHUB_OUTPUT"
            break
          fi

          if [ $i -eq $max_attempts ]; then
            echo "::error ::Unable to pull image after $max_attempts attempts: ${{ inputs.push-registry }}/${{ inputs.image-name }}:$existing_tag. Please re-run this failed steps"
            # ACR is strongly throttling us. Don't be nice, just let the developer re-run the failed step
            exit 1
          else
            sleep $((10 + i * 5))
            echo "${i} - retry pulling '${{ inputs.push-registry }}/${{ inputs.image-name }}:$existing_tag'"
          fi
        done

    - name: Add missing tags
      if: ${{ steps.determine-missing-tags.outputs.missing-tags != '' && steps.pull-existing-image.outputs.image-pulled == 'yes' && inputs.push }}
      shell: bash
      run: |
        set -x
        # step: Add missing tags
        existing_tag="${{ steps.determine-existing-image.outputs.existing-tag }}"
        IFS=',' read -ra missing_tags <<< "${{ steps.determine-missing-tags.outputs.missing-tags }}"
        for tag in "${missing_tags[@]}"; do
          echo "::notice ::Tag '${{ inputs.image-name }}:$tag' is missing, adding it from '${{ inputs.image-name }}:$existing_tag'"
          push_registry1='${{ inputs.push-registry }}'
          docker tag "${push_registry1%/}/${{ inputs.image-name }}:$existing_tag" \
                     "${push_registry1%/}/${{ inputs.image-name }}:$tag"
        
          max_attempts=3
          for ((i=1; i<=max_attempts; i++)); do
            set +e
            docker push "${push_registry1%/}/${{ inputs.image-name }}:$tag"
            status_code=$?
            set -e
            if [ $status_code -eq 0 ]; then
              break
            fi
  
            if [ $i -eq $max_attempts ]; then
              echo "::error ::Unable push image tag after $max_attempts attempts: ${{ inputs.push-registry }}/${{ inputs.image-name }}:$tag. Please re-run this failed steps"
              # ACR is strongly throttling us. Don't be nice, just let the developer re-run the failed step
              exit 1
            else
              sleep $((10 + i * 5))
              echo "${i} - retry pushing tag '${{ inputs.push-registry }}/${{ inputs.image-name }}:$tag'"
            fi
          done
        done

name: Update deployment manifest
description: A composite action that updates deployment manifest

inputs:
  target-env:
    description: |
      The deployment environment, such as dev qa uat load stg prod. Can be either a single name or a comma-separated list of names.
      Note: stg and prod must not be mixed with other environments. stg and prod must not be deployed at the same time.
    required: true
  images-map:
    description: string of pairs image=uri to update the kustomization file
    required: true
  app-name:
    description: |
      A short business friendly name, just to construct the commit message to gitops repo.
      If this is not provided and gitops-app-name is provided, gitops-app-name will be used.
      You can specify both app-name and gitops-app-name, in that case, app-name will be used to build the gitops commit message,
      i.e. app-name can be an abbreviation.
    required: false
  gitops-app-name:
    description: |
      If provided and
      - If app-name is not provided, this is used for app-name.
      - If gitops-overlay-folder is not provided, the folder will be: apps/<gitops-app-name>/overlays/<target-env>
    required: false
  gitops-overlay-folder:
    description: |
      If this is not provided and gitops-app-name is provided, the value that will be used is: apps/<gitops-app-name>/overlays
      
      When target-env contains multiple environments, file <gitops-overlay-folder>/<env>/kustomization.yaml will be edited.
      When only one environment name is provided, 
      if <gitops-overlay-folder>/<env> exist, <gitops-overlay-folder>/<env>/kustomization.yaml will be edited,
      otherwise file <gitops-overlay-folder>/kustomization.yaml will be edited.
    required: false
  gitops-repo-deployment-key:
    description: |
      The ssh key to clone and update the gitops repository.
      Mandatory, but mutual exclusive with the pair gitops-repo-app-id gitops-repo-app-private-key
    required: false
  gitops-repo-app-id:
    description: |
      The github AppID for obtaining a token, which is used to clone and update gitops repository.
      Mandatory, but mutual exclusive with gitops-repo-deployment-key.
      If gitops-repo-app-private-key is specified but this input is not specified, default to github action variable GH_ACTION_APPID
    required: false
  gitops-repo-app-private-key:
    description: |
      The private key of the github AppID for obtaining a token, which is used to clone and update gitops repository.
      Mandatory, but mutual exclusive with gitops-repo-deployment-key.
    required: false
  gitops-repo:
    description: |
      For example ecap-tech/eclipse-gitops. If not provided, the github action variable GITOPS_REPO will be used if defined.
      If GHA variable GITOPS_REPO is not defined either, 
      repo ecap-tech/eks-prod-001-manifests will be used if the target-env is either prod or stg, 
      otherwise, default to repo ecap-tech/eks-nonprod-001-manifests
    required: false
  gitops-branch:
    description: If not provided, the github action variable GITOPS_BRANCH will be used, if not, use value main
    required: false

  GA_REPO_PERMISSIONS_EXAMINATION_KEY:
    description: from secrets.GA_REPO_PERMISSIONS_EXAMINATION_KEY. The key used, with the repo-permissions app key, to check this repository for environment protection rules for the <target-env> environment. Required for micro-services.
    default: ""
    required: false

  vars:
    description: from the caller workflow, just pass this function call toJson(vars)
    required: true

runs:
  using: composite
  steps:
    - name: process action variables
      shell: bash
      run: |
        # step: process action variables. Check mandatory inputs and make default values
        
        APP_DISPLAY_NAME="${{ inputs.app-name }}"
        if [ "${{ inputs.app-name }}" = "" ]; then
          if [ "${{ inputs.gitops-app-name }}" = "" ]; then
            echo "::error ::input argument app-name must not be empty."
            exit 1
          fi
          APP_DISPLAY_NAME="${{ inputs.gitops-app-name }}"
        fi
        echo "APP_DISPLAY_NAME=${APP_DISPLAY_NAME}" >> $GITHUB_ENV
        
        GITOPS_OVERLAY_FOLDER="${{ inputs.gitops-overlay-folder }}"
        if [ "${{ inputs.gitops-overlay-folder }}" = "" ]; then
          if [ "${{ inputs.gitops-app-name }}" = "" ]; then
            echo "::error ::input argument gitops-overlay-folder must not be empty"
            exit 1
          fi
          GITOPS_OVERLAY_FOLDER="apps/${{ inputs.gitops-app-name }}/overlays"
        fi
        echo "GITOPS_OVERLAY_FOLDER=${GITOPS_OVERLAY_FOLDER}" >> $GITHUB_ENV
        
        if [ "${{ inputs.target-env }}" = "" ]; then echo "::error ::input argument target-env must not be empty"; exit 1; fi
        if [ "${{ inputs.gitops-repo-deployment-key }}" = "" ] && \
           [ "${{ inputs.gitops-repo-app-id }}" = "" ] && \
           [ "${{ inputs.gitops-repo-app-private-key }}" = "" ]; then
          echo "::error ::Either gitops-repo-deployment-key or the pair gitops-repo-app-id, gitops-repo-app-private-key must be provided";
          exit 1;
        fi
        if [ "${{ inputs.gitops-repo-deployment-key }}" != "" ] && [ "${{ inputs.gitops-repo-app-id }}" != "" ]; then
          echo "::error ::Must not provide both gitops-repo-deployment-key and the pair gitops-repo-app-id, gitops-repo-app-private-key";
          exit 1;
        fi

        GITOPS_REPO_APP_ID="${{ inputs.gitops-repo-app-id }}"
        if [ "${{ inputs.gitops-repo-app-id }}" = "" ] && \
           [ "${{ inputs.gitops-repo-app-private-key }}" != "" ]; then
          GITOPS_REPO_APP_ID="${{ fromJson(inputs.vars).GH_ACTION_APPID }}"
        fi
        echo "GITOPS_REPO_APP_ID=${GITOPS_REPO_APP_ID}" >> $GITHUB_ENV
        
        GITOPS_REPO="${{ inputs.gitops-repo || fromJson(inputs.vars).GITOPS_REPO }}"
        if [ "$GITOPS_REPO" = "" ];then
          if echo "${{ inputs.target-env }}" | grep -qE "stg|prod"; then
            GITOPS_REPO='ecap-tech/eks-prod-001-manifests'
          else
            GITOPS_REPO='ecap-tech/eks-nonprod-001-manifests'
          fi
          echo "GITOPS_REPO is not explicitly defined, default to repo $GITOPS_REPO because of the deployment environment ${{ inputs.target-env }}"
        fi

        echo "GITOPS_REPO=${GITOPS_REPO}" >> $GITHUB_ENV
        echo "GITOPS_BRANCH=${{ inputs.gitops-branch || fromJson(inputs.vars).GITOPS_BRANCH || 'main' }}" >> $GITHUB_ENV

    - name: determine image tag
      shell: bash
      run: |
        # step: determine image tag
        IMAGES_MAP="${{ inputs.images-map }}"
        # trim surrounding spaces
        IMAGES_MAP=$(echo ${IMAGES_MAP} | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//')
        echo "IMAGES_MAP=${IMAGES_MAP}" >> $GITHUB_ENV
        
        # extract the tag value from the first image in the map
        if [ "${IMAGES_MAP}" != "" ]; then
          FIRST_TOKEN="${IMAGES_MAP%% *}"
          tag_with_digest="${FIRST_TOKEN#*:}"
          tag="${tag_with_digest%@*}"
          echo "IMAGES_TAG=${tag}" >> $GITHUB_ENV
        fi

    - name: Obtain app token for cloning gitops repo
      if: ${{ env.IMAGES_MAP != '' && inputs.gitops-repo-app-private-key != '' }}
      uses: actions/create-github-app-token@v1
      id: get-clone-token
      with:
        app-id: ${{ env.GITOPS_REPO_APP_ID }}
        owner: ${{ github.repository_owner }}
        private-key: ${{ inputs.gitops-repo-app-private-key }}

    - name: Clone ${{ env.GITOPS_REPO }} by app token
      if: ${{ env.IMAGES_MAP != '' && inputs.gitops-repo-app-private-key != '' }}
      uses: actions/checkout@v4
      with:
        repository: ${{ env.GITOPS_REPO }}
        ref: ${{ env.GITOPS_BRANCH }}
        token: ${{ steps.get-clone-token.outputs.token }}
        path: gitops

    - name: Clone ${{ env.GITOPS_REPO }} by deploymnet key
      if: ${{ env.IMAGES_MAP != '' && inputs.gitops-repo-deployment-key != '' }}
      uses: actions/checkout@v4
      with:
        repository: ${{ env.GITOPS_REPO }}
        ref: ${{ env.GITOPS_BRANCH }}
        ssh-key: ${{ inputs.gitops-repo-deployment-key }}
        path: gitops

    # after checkout
    - name: Micro-Services Environment Check
      id: is-micro-svc
      shell: bash
      run: |
        # If we are a micro-service, but we don't have the github-actions secret to read
        # repository environmental protection, then exit -- misconfigured.

        if [ -z '${{ inputs.target-env }}' ] || [ '${{ inputs.target-env }}' = dev ]; then
            # Deploying to dev -- don't check for env-protection rules.
            exit
        fi

        is_microsvc=false
        for f in .config/values*.yaml; do [ -f "$f" ] && { is_microsvc=true; break; }; done
        if $is_microsvc; then
            echo 'IS_MICROSVC=true' >> $GITHUB_OUTPUT

            if [ -z '${{ inputs.GA_REPO_PERMISSIONS_EXAMINATION_KEY }}' ]; then
                echo '::error ::Detected micro service, however missing the repo permissions-check key, GA_REPO_PERMISSIONS_EXAMINATION_KEY'
                exit 1
            fi
        else
            echo 'IS_MICROSVC=false' >> $GITHUB_OUTPUT
            exit
        fi

#    - name: Micro-Services Environment Check - Token
#      if: ${{ steps.is-micro-svc.outputs.IS_MICROSVC }}
#      id: micro-svc-env-check-token
#      uses: actions/create-github-app-token@v2
#      with:
#        # Github App ID that has access to private go module repos
#        app-id: ${{ fromJson(inputs.vars).GA_REPO_PERMISSIONS_EXAMINATION_ID }}
#        # The app token for this app
#        private-key: ${{ inputs.GA_REPO_PERMISSIONS_EXAMINATION_KEY }}
#        #repositories:
#        #- sigh, I wish I could say "this one" but there's no github context entry to do that.
#        permission-actions: read
#        permission-environments: read

#    - name: Micro-Services Environment Check 
#      if: ${{ steps.is-micro-svc.outputs.IS_MICROSVC }}
#      shell: bash
#      run: |
#        [ $(curl -s -L \
#            -H "Accept: application/vnd.github+json" \
#            -H "Authorization: Bearer ${{ steps.micro-svc-env-check-token.outputs.token }}" \
#            -H "X-GitHub-Api-Version: 2022-11-28" \
#            'https://api.github.com/repos/${{ github.repository }}/environments/${{ inputs.target-env }}' |
#            jq '.protection_rules[].reviewers[]' | wc -l) -gt 2 ] || {
#                echo '::error ::Unable to get reviewer protection rules for environment; halting.'
#                exit 1
#            }

    - name: Update ${{ inputs.target-env }} manifests for deployment
      if: env.IMAGES_MAP != ''
      shell: bash
      run: |
        # step: Update ${{ inputs.target-env }} manifests for deployment
        set -x

        accountid() {
            local acct
            # Get the account ID from the root of the manifests repository.
            if ! [ -f "$GITHUB_WORKSPACE/gitops/.config/account.yaml" ]; then
                echo "::error ::This manifests repository is not configured with account information. Unable to fetch aws_account_id for deployment."
                exit 1
            fi

            # Account yaml format can be either:
            # aws_account_id: 123
            # ---
            # aws_account_id:
            #  dev: 123
            #  stage: 1234
            # Because I can't figure out how to examine structure with yq, I'm using grep.

            acct="$( yq '.aws_account_id' "$GITHUB_WORKSPACE/gitops/.config/account.yaml" |
                grep --max-count=1 -o '^[0-9]\+$\|^${{ inputs.target-env }}: [0-9]\+$' |
                sed 's/^${{ inputs.target-env }}:[[:space:]]*//')"
            if [ ${#acct} -ne 12 ]; then
                echo "::error ::This repository is not configured with account information. Account id has incorrect number of digits (12): $acct."
                exit 1
            fi

            echo "$acct"
        }

        # convert comma-separated string to list of string
        IFS=',' read -ra env_list <<< "${{ inputs.target-env }}"

        is_microsvc=false
        [ -f "$GITHUB_WORKSPACE/.config/values.yaml" ] || [ -f "$GITHUB_WORKSPACE/.config/values-${{ inputs.target-env }}.yaml" ] &&
            is_microsvc=true

        if ! $is_microsvc; then
            echo "Error: Misconfigured service. Missing .config/values*.yaml."
            exit 1
        fi
        
        max_attempts=6
        for ((i=1; i<=max_attempts; i++)); do
          cd "${GITHUB_WORKSPACE}/gitops"
          ls -l

          # just for retries: discard previous local commit and start over. No effect in the first time
          git reset --hard origin/${{ env.GITOPS_BRANCH }}
          git clean -xfd
          git pull
          
          # Re-template the service files. Every time, because it's fast (relatively).
          # this means: micro-service deployment. Only one overlay, one per deployment.
          # pwd: gitops dir.
          repo_name='${{ env.GITOPS_OVERLAY_FOLDER }}' # ' syntax highlighting fix
          repo_name="${repo_name%/overlay*}"    # definition: /apps/xxx/overlays/dev -> /apps/xxx
          repo_name="${repo_name##*/}"    # "vim fix

          if ! grep -q '^[a-z][-a-z0-9_]\+$' <<< "$repo_name"; then
            echo "::error ::Unable to properly determine repo name. Got: \"$repo_name\""
            exit 1
          fi

          # Which values files do we have? -- order matters!!
          values=()
          for f in "$GITHUB_WORKSPACE/.config/values.yaml" "$GITHUB_WORKSPACE/.config/values-${{ inputs.target-env }}.yaml"; do
             [ -f "$f" ] && values+=( --values "$f" )
          done

          aws_account_id="$(accountid)"
          if [ $? -ne 0 ]; then
            # error getting account ID
            echo "$aws_account_id"
            exit 1
          fi

          # The helm chart is stored in this repository, common for prod and non-prod.
          #helm template "$repo_name" "${GITHUB_ACTION_PATH%.github/actions/*}/helm-templates/DeCapMicroService" \
          helm template "$repo_name" "$GITHUB_WORKSPACE/gitops/DeCapMicroService" \
             --namespace "$repo_name-${{ inputs.target-env }}" \
             "${values[@]}" \
             --set env='${{ inputs.target-env }}' \
             --set aws_account_id="$aws_account_id" \
                > chart.$$.yaml || ret=$?
          # ' syntax highlight fix

          if [ ${ret:-0} -ne 0 ]; then
            helm template --debug "$repo_name" "$GITHUB_WORKSPACE/gitops/DeCapMicroService" \
               --namespace "$repo_name-${{ inputs.target-env }}" \
               "${values[@]}" \
               --set env='${{ inputs.target-env }}' \
               --set aws_account_id="$aws_account_id"
               # '
            
            exit $?
          fi

          targetenvdir='${{ env.GITOPS_OVERLAY_FOLDER }}/${{ inputs.target-env }}'  #'
          # if it doesn't have the generated dir, then assume we need to create the infra-layer kustomization
          if ! { [ -d "$targetenvdir/generated" ] &&
                 [ -f "$targetenvdir/kustomization.yaml" ]; }; then
              mkdir -p "$targetenvdir/generated"
              {
                echo 'kind: Kustomization'
                echo 'apiVersion: kustomize.config.k8s.io/v1beta1'
                echo
                echo '# Generated resources will be replaced each deployment. This kustomization will not be.'
                echo 'resources:'
                echo '- generated'
              } > "$targetenvdir/kustomization.yaml"
          fi

          # Now split the generated yaml into its kustomization.yaml and its chart values
          yq 'del(select(.kind == "Kustomization" or .kind == "Auto!Generated"))' chart.$$.yaml \
              > "$targetenvdir/generated/chart.yaml"
          yq 'select(select(.kind == "Auto!Generated")) | .info' chart.$$.yaml \
              > "$targetenvdir/generated/!Auto-Generated!.txt"
          yq 'select(.kind == "Kustomization")' chart.$$.yaml \
              > "$targetenvdir/generated/kustomization.yaml"
          rm chart.$$.yaml

          for f in generated/chart.yaml generated/kustomization.yaml kustomization.yaml \
              '/generated/!Auto-Generated!.txt'; do
            git add "$targetenvdir/$f"
            [ -s "$targetenvdir/$f" ] && continue
            echo "::error ::Got zero-size $f; this is invalid!"
            exit 1
          done

          # Is it in the Workload sync file?
          syncf="$GITHUB_WORKSPACE/gitops/workload/_overlays/prod/sync.yaml"
          if ! grep -qF "  name: $repo_name" "$syncf"; then

            llst="$(tail -n2 "$syncf")"
            if [ "$llst" != "${llst##*---}" ]; then
                echo '---' >> "$syncf"
            fi

            # namespace: the namespace of the kustomization, not the services within.
            # underscore: converted to newline.
            echo "apiVersion: kustomize.toolkit.fluxcd.io/v1_kind: Kustomization_metadata:_  name: ${repo_name}_  namespace: flux-system_spec:_  interval: 10m0s_  path: ./${{ env.GITOPS_OVERLAY_FOLDER }}/${{ inputs.target-env }}_  prune: true_  sourceRef:_    kind: GitRepository_    name: flux-system_  targetNamespace: ${{ inputs.target-env }}_  dependsOn:_    - name: workload_  postBuild:_    substitute:_      env: \${env}_      awsAccountId: \"$aws_account_id\"_---" |
                tr _ \\n >> "$syncf"
          fi

          # Change to the *generated* overlay dir to update the kustomization with the proper image map.
          # (they can override this. Bad, bad end user!)
          cd "$targetenvdir/generated"

          kustomize edit set image ${{ env.IMAGES_MAP }}
        
          git config user.name github-actions
          git config user.email github-actions@github.com
          # skip non-zero exit code if nothing to add
          set +e
          git commit -am "Update image tag ${{ env.APP_DISPLAY_NAME }} ${{ env.IMAGES_TAG }} to env ${{ inputs.target-env }}"
          set -e

          # pushing can be rejected due to other pushes 
          git push && break || ret=$?
          if [ $i -eq $max_attempts ]; then
            echo "::error ::Retries exceeded. Something is wrong pushing to upstream git repo."
            exit ${ret:-12}
          fi
          
          sleep 5
          echo "${i}- retry pushing manifest update to gitops repo"
        done

        # so that we can see what was just done, after all retries.
        git show

    - name: final summary
      shell: bash
      run: |
        # step: final summary
        if [ "${IMAGES_TAG}" != '' ]; then
          echo ":rocket: Sent the following container images for **${{ inputs.target-env }}** deployment" >> $GITHUB_STEP_SUMMARY
          echo "Image tag: **${{ env.IMAGES_TAG }}**" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${IMAGES_MAP}" = "" ]; then
          echo ":no_entry: Nothing deployed!" >> $GITHUB_STEP_SUMMARY
        else
          IMAGES_MAP=$(echo "$IMAGES_MAP" | tr ' ' '\n' | sort | tr '\n' ' ')
          for entry in ${IMAGES_MAP}; do
            entry=$(echo "$entry" | tr -d '[:space:]')
            echo "* ${entry%%=*}" >> $GITHUB_STEP_SUMMARY
          done
        fi
